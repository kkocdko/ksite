<!DOCTYPE html>

<head>
  <meta name="viewport" content="width=device-width" />
  <link rel="icon" href="data:" />
  <title>Meet - ksite</title>
</head>

<style>
  * {
    appearance: none;
    margin: 0;
    font: 14px / 20px sans-serif;
    background: #fff;
  }
  @media (prefers-color-scheme: dark) {
    * {
      color: #fff;
      background: #000;
    }
  }
  body {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header > *,
  header ~ * {
    padding: 8px 10px;
    border: 0 solid #888;
    outline: 0;
  }
  header > * {
    float: left;
    border-right-width: 1px;
  }
  header > :active {
    background: #8887;
  }
  header ~ * {
    border-top-width: 1px;
  }
  select {
    width: min(calc(50vw - 5em), 200px);
  }
  video {
    max-width: 100%;
    max-height: 100%;
    padding: 0;
    box-shadow: 1px 1px #777;
    background: #000;
  }
  video:fullscreen {
    border: none;
  }
</style>

<body>
  <header>
    <button id="$trigger" style="display: none">Start</button>
    <button id="$tx2">DEMOTX</button>
    <button id="$tx">TX</button>
    <button id="$rx">RX</button>
    <button id="$detail">Detail</button>
    <select id="$audio">
      <option value="({})">Default audio</option>
      <option value="false">No audio</option>
    </select>
    <select id="$video">
      <option value="({})">Default video</option>
      <option value="false">No video</option>
    </select>
  </header>
  <div></div>
</body>

<script>
  const pull = async (path) => {
    while (true) {
      let data = JSON.parse(localStorage[path] || "[]");
      let item = data.shift();
      if (item) {
        localStorage[path] = JSON.stringify(data);
        return JSON.parse(item);
      }
      await new Promise((r) => setTimeout(r, 200));
    }
    // while (true) {
    //   const t = await fetch(p).then((r) => r.text());
    //   if (t) {
    //     await fetch(p, { method: "POST", body: "" });
    //     return JSON.parse(t);
    //   }
    //   await new Promise((r) => setTimeout(r, 200));
    // }
  };
  const push = async (path, item) => {
    // await fetch(p, { method: "POST", body: JSON.stringify(t) });
    let data = localStorage[path] ? JSON.parse(localStorage[path]) : [];
    data.push(JSON.stringify(item));
    localStorage[path] = JSON.stringify(data);
  };
</script>

<script type="module">
  const sdpTransform = (sdpStr) => {
    // https://stackoverflow.com/questions/29302617/control-video-send-framerate-on-the-fly-in-webrtc
    // https://stackoverflow.com/a/57674478/11338291
    const [MAX, MIN, START] = [12000, 10000, 11000]; // bitrate
    const ret = sdpStr.split("\r\n").map((e) => {
      if (/^a=fmtp:\d*/.test(e)) {
        e += `;x-google-max-bitrate=${MAX};x-google-min-bitrate=${MIN};x-google-start-bitrate=${START}`;
      } else if (/^a=mid:(1|video)/.test(e)) {
        e += `\r\nb=AS:${MAX}`;
      }
      return e;
    });
    return ret.join("\r\n");
  };
  for (const device of await navigator.mediaDevices.enumerateDevices()) {
    ({ audioinput: $audio, videoinput: $video }[
      device.kind
    ]?.insertAdjacentHTML(
      "beforeend",
      `<option value="({deviceId:'${device.deviceId}',width:1920,frameRate:30})">${device.label}</option>`
      // `<option value="({deviceId:'${device.deviceId}'})">${device.label}</option>`
    ));
  }
  let stream, recorder;
  $audio.onchange = $video.onchange = async () => {
    // width: { max: 1280 }, height: { max: 720 }, facingMode: { ideal: "environment" },
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints
    stream?.getTracks().forEach((t) => (t.stop(), stream.removeTrack(t)));
    const streamCfg = { audio: eval($audio.value), video: eval($video.value) };
    // https://stackoverflow.com/a/73550841/11338291
    stream = await navigator.mediaDevices.getUserMedia(streamCfg);
    $preview.srcObject = stream;
  };
  $audio.onchange();
  $detail.onclick = () => {
    const modify = (el) => (el.value = prompt(el.parentNode.id, el.value));
    modify($audio.selectedOptions[0]);
    modify($video.selectedOptions[0]);
    $audio.onchange();
  };
  $trigger.onclick = async () => {
    if (!/(^|;)auth=/.test(document.cookie)) return (location = "/media/auth");
    if ($trigger.textContent === "Stop") {
      $trigger.textContent = "Start";
      recorder.stop();
      recorder = null;
      return;
    }
    $trigger.textContent = "Stop";
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = ({ data }) => {
      fetch("/emergency/upload", {
        // keepalive: true, // default is true
        method: "post",
        headers: { "content-type": data.type },
        body: data,
      }).catch((e) => console.log(e));
    };
    recorder.start(500);
  };

  $tx.onclick = async () => {
    const pctx = new RTCPeerConnection();
    pctx.onicecandidate = (e) => push("/media/rx/candidate", e.candidate);
    // for (const t of stream.getTracks()) pctx.addTrack(t, stream);
    pctx.addTrack(stream.getVideoTracks()[0], stream);

    const offer = await pctx.createOffer();
    await push("/media/rx/offer", offer);
    await pctx.setLocalDescription(offer);
    (async () => {
      while (true)
        await pull("/media/tx/candidate").then((c) => {
          if (c) {
            console.log(c);
            pctx.addIceCandidate(c);
          }
        });
    })();
    (async () => {
      while (true)
        await pull("/media/tx/answer").then((c) => {
          pctx.setRemoteDescription(c);
        });
    })();
  };
  $rx.onclick = async () => {
    const pcrx = new RTCPeerConnection();
    pcrx.onicecandidate = (e) => push("/media/tx/candidate", e.candidate);
    pcrx.ontrack = (e) => ($preview.srcObject = e.streams[0]);
    await pcrx.setRemoteDescription(await pull("/media/rx/offer"));
    const answer = await pcrx.createAnswer();
    answer.sdp = sdpTransform(answer.sdp);
    await push("/media/tx/answer", answer);
    await pcrx.setLocalDescription(answer);
    (async () => {
      while (true)
        await pull("/media/rx/candidate").then((c) => {
          if (c) {
            console.log(c);
            pcrx.addIceCandidate(c);
          }
        });
    })();
  };
</script>
